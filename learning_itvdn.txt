11.04.2021 start learning python anew

    1.1 примитивные типы данных

shift + 9 = взять переменную в круглые скобки
id показать айди переменной

ключевые слова
['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def',
 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal',
 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

str = строка
сложить строки +  умножить строки *             конкатинация

len = для того что-бы узнать длину строки
v="324234534"
print(len(v))    :: 9

upper / lower  перевод в верхний / нижний регистр
m = "paMbu"
z = "PAmBU"
print(m.upper())    :: PAMBU
print(z.lower())    :: pambu

числа
получение целой части от деления  5//2 :: 2
получение остатка от деления      5%2  :: 1
смена знака -2 :: -2
модуль числа  abs(-3) :: 3
возведение в степень 2**2   :: 4

логические типы данных True = 1 False = 0   bool(1) true       bool(0) false  любой обьект кроме 0 это true

none = абсолютное отсуствие чего либо

    1.2 логические типы
== сравнение
!= не равно
> больше
< меньше
>= больше равно
<= меньше равно

    1.3    Условные операторы if else
pass заглушка которая не выполняет ничего
if
elif
else

тернарный оператор
что мы хотим вернуть if выражение истинно else вернеться если выражение ложно
value = 23 if z >= 3 else print("syka bleit")
print("suka") if 7>=5 else print("fuck you")

value = 20
result_value_greater_than_zero = True if value > 0 else False
print(result_value_greater_than_zero)

a = a + b  :: a+=b  сокращение
a += b
-=
/=
*=

if not можно использовать == если нет, то что-то далее

if first_value is None or second_value is None ::  пример двойного условия

    1.4 Циклы
цикл - конструкция для перебора елементов или многократного выполнения участка кода

for и while есть в пайтоне

range(n) генерирует от 0 до n не включая последний

while услвие:
    тело цикла
Он будет выполняться пока условное число истинное, важно сделать что-бы цикл имел свой предел. нужно сделать так что-бы условие сталоо ложным

for элемент in обект:
    тело

Он будет проходиться по конкретному обьекту, пока не дойдет до его последнего елемента. Текущий элемент на итерации будет находиться в переменной которую вы зададите после слова for

continue пропускаект текущую итерацию  / не прервет цикл, можно продожить с любыми другими значениями его
перебираем яблоки для салата и если гнилые на гнилых останавливаемся и убираем их

break дозволяет досрочно завершить выполнение цикла / прервет цикл
ищем монетку среди пуговиц

pass заглушка

    1.5 список и срезы
списки - упорядоченные коллекции обьектов различных типов
у каждого списка есть свой индекс, который отвечает его порядковому номеру в списке
списки могут хранить разные типы обьектов
индексация начинается с 0
для обращения к конкретному элементу нужно после его названия в квадратный скобках указать индекс элемента
list
можно создавть списки не через list, а [1,2,3]


    срезы списков
Для того что-бы сделать выборку более чем по одному элементу, можно использовать срезы, которые вернут подмножество элементов списка
синтакси : my_list[start:stop:step]
start = индекс с которого начнеться подмножество
stop  = индекс перед которым закончиться пожмножество
step = шаг выбора эдементов

    методы списков
append() - добавление нового элемента в конец списка  my_list.append('Hello')
clear() - удалить все элементы списка
extend() - расширяет список переданной последовательностью ! можно просто соеденять списки + сложились(сконкатенировались) но если вывести отдельно любой из их то они будут не сложенные
но если сделать a = a+b то список а соедениться () += работает
index() - возвращает index указаного элемента, если таких элементов несколько - вернет первый найденный
pop() - удаляет элемнет указанного индекса и возвращает его (можно сохранить куда-то удаленный элементе )
reverse() - зеркально отображает список
sort() - сотирует список. Если указать в парметрах reverse =True, тогда сортирова будет в обратном порядке

    обход списков
списки можно обходить с помощью циклов
синтаксис
for element in my_list:
    ...

    1.6 словари

Словари - это упорядоченные коллекции формата ключ - значение. Значением может быть любой обьект, ключом которого может быть только неименяемый обьект.
упорядоченные - указывает что у каждого обьекта есть свой порядковый номер (ключ) : почти как индекс в списке
в случае со словарями вы сами определяете индекс "001" или имя

ключем могут быть только неизменяемые обьекты
списки не могут быть ключами словарей
так-же как и другие словари не могу быть ключами словарей

вы можете положить туда элемент - число, строка, список, список списков и что хочешь

    синтаксис словарей

{'key':'value'}
вывести name_dict=['key'] или name_dict.get('key')
где key - ключ по которому доступен элемент value.
Для того что-бы получить наше значение по ключу, достаточно после написания словаря в квадратных скобках указать название ключа. так-же можно использовать метод get()
который в случает отсутсвия элемента по такому ключу вернет None

отличие [''] от .get('key')
при [] будет выведена ошибка
при .get() будет показано None, так-же через запятую можно будет выбрать какое значение вывести если ключа нету print(my_dict.get(12 , -1)) выедет -1 если нету ключа 12

    методы словарей
clear() - очищает полостью словарь
items() - возвращает пару ключ-значение
pop(key) - удаляет ключ и возвращает соответствующее ему значение
popitem() - удаляет последнее значение и возвращает его в формате ключ значение
update({'key':'value}) - добавляет новое ключ значение ! можно добавить другой словать
values() - возвращает все значения(values) в словарь


    1.7  множества кортежи

множества - структура данных, не содержащая повторяющихся элементов. Множества не поддерживают индексацию,
поэтому достук к элементам возможен перебором
синтакси множест: {1,2,3,4}
set()    - пустое множество


методы множеств
clear() - очищает множество
pop() - удаляет первый элемент множества
discard(elem) - удаляет элемент из множества  - удаляет не по индексу, а по значению
remove(elem) - удаляет элемент из множества. Если такого элемента нету, то выдает ошибку
add(elem) - добвляет элемент в множество (если элемент есть то ошибки не будет)
union(another_set) - обьеденяет множество (если будут дубликаты то будут отброшенны)
intersection(another_set) - находит пересечение множеств
difference(another_set) - разница множеств
elem in set_name - находиться ли элемент в множестве


    кортеж
кортеж(tuple) - неизменяемый список
синтаксис кортежей:
(1,2,3)
нельзя менять, это чисто константа - времена года/ дни недели

кортежам свойственны все методы списков, не изменяющие его. Очень часто встречаеться случай использования кортежей для того что-бы поменять элементы местами
для этого достаточо прописать a,b = b,a

методы кортежей
также при прохождении по списку кортежей, цикл for может принимать столько значений сколько элементов в tuple
синтакси
for elem1, elem2 in [(1,2), (2,4)]:                 каждый элемент нашего списка это кортеж
    print(elem1, elem2)
:: (1,2)
   (2,4)

    1.8 Функции 1 урок

функции - это обьект, который принимает и возвращает значение. функцию можно вызвать из любого места в оде для повторного использования.
Эта концепция помогает избежать повторяющихся участков кода, а также разбивать программу на подпрограммы, чо улучшает читаемость кода

для того что-бы создать функцию, нужно воспользоваться специальным словом def

синтакси
def my_function():
    ...

Для того чтобы можно было менять поведение функции. можно передаватоь параметры которые будут использоваться дальше в коде.
Для этого пропишите в скобках название параметра и используйте это название в своей логике в теле функции

возврат результатов: от функции зачастую ожидают, что она вернет какое-то значене, в зависимости от параметров для дальнейшего использования в коде.
Например, можно присвоить результат функции в переменную

Для того чтобы вернуть результат функции, нужно воспользоваться специальным слово return


    1.8 Функции 2 урок

Область видимости - это область, в которой интерпретатору доступны ваши переменные, функции ипрочее. Область видимости бывает локальнаая и глобальная
Перменнае, которые обьявлены вне функции, называються глобальными переменными в Python. Эти переменные имеют большую область видимост и доступны всем функциям,
котоые определены после обьявления глобальной переменной.

Когда переменная обявляеться внутри функции, то это локальная переменная. Область действия локальной переменной ограничена функцией, в которой она создаеться.
Это означает, что она доступна в функции, где она обьявлена, но не вне этой функции

x = 2                   глобальный x
def print(x):
    x = 2               локальный x
    print(x)            локальный x можно вывести с функции с помощью return
z = print(x)
:: 2

функция внутри другой функции = локальная функция

функции преобразования типов - нужны для того, чтобы можно было создавать новые обьекты определения типо
str - преобразовать в строку                            str(1)  = '1'
int - преобразовать в не целое число                    int(1) = 1
float - преобразование в не целое число ( дробное )     float(12) = 12.0
list - преобразовать в список                           list('123') = ['1','2', '3']
dict - преобразовать в словарь                          dict(['key', 'value']) = {'key': 'value'}
set - преобразовать в множество                         set([1,2,3,3,3]) = {1,2,3}
tuple - преобразовать в кортеж                          tuple('123') = ('1','2','3')
bool - преобрезовать в bool                             bool(1) = True


14.04
Стандартные функции

sum - возвращает сумму набора чисел
sum([1,2,3]) :: 6

min i max - возвращает минимум и максимум из набора чисел соответственно
min ([1,2,3]) :: 1
max ([1,2,3]) :: 3

Анонимные фнкции - используються в случае, если нам их нужно куда-то передать и больше мы не будем их использовать повторно
Такая запись будет компактней. У такой функции не будет имени

Синтаксис
lambda x: x
Где - x - это параметр, который передается в функцию, а второй - то, что возвращается

Эквивалент обычной функции:
def some_name(x):
    return x

x = [1,2,3,4,5]
def some_func(function):
    for element in x:
        print(function(element))
some_func(lambda a: a+10) :: 11 12 13 14 15


Рекурсия - это когда функция вызывает сама себя. В рекурсии обязательно должна быть конечная глубина для того,
что-бы не было зацикливания

def factorial(n):
    if n==0:
        return 1
    else:
        return n* factorial(n-1)
print(factorial(4)) :: 24



10 урок Исключение и их обработка

try
except

assents проверяет равенство





        2 Базовий ооп 24.06.22
        наследования, инкапсуляция, полоиморфизм, абстракция

Обьектно-ориентированное программирование - предоставление программы в виде совокупности обьектов, каждый из которых
является экземпляром определенного класса, а классы образуют иерархию наследования.


●ООП или объектно-ориентированное программирование — это одна из многих
парадигм в программировании и в языке Python она тоже реализована, и является
очень полезным и мощным инструментом в разработке программ. ООП строится на 4
основных принципах: наследование, инкапсуляция, полиморфизм и абстракция.
● Ключевыми понятиями в ООП являются класс и объект класса. Класс - общее понятие
(растение, предмет мебели), а объект или объект класса — это уже конкретное понятие
(одуванчик (растение), стул (предмет мебели)). Данная концепция лежит в основе ООП.
● ООП не является единственным стилем программирования, можно писать программы и
без него. Но владение им дает неоспоримое преимущество в качестве написания кода и
несет в себе массу полезных свойств.
● Наследование является относительно простой идеей. Вы можете создать иерархию
классов, где есть материнские (от которых наследуются) и дочерние классы (которые
наследуются от материнских).
● Ключевая идея наследования такая же, как и в биологии. Дочерние классы-наследники
“перенимают” от материнских их атрибуты и методы. То есть вам не нужно заново их
прописывать. Но какой смысл наследования одного и того же без изменений? Никакого.
● Если вы используете наследование, то всегда должны в дочерних классах что-то
изменять или добавлять.
● Например, материнский класс Car (автомобиль) может ездить (вперед, назад,
поворачивать). Если вы от него унаследуете класс FlyingCar (летающая машина), то
можете ему добавить функцию полета, при этом летать она сможет так же - вперед,
назад и поворачивать, как и материнский класс
●Также существует множественное наследование, когда материнских классов у дочернего
не один, а несколько. Например, класс SuperUser с расширенными правами может быть
унаследован от класса Admin и User, при этом имея функции юзера и права
администратора.



class Human:
    def __int__(self,name,age):  - self ссылка на самого себя. определенный скрипт главный
        self.name = name                = атрибуты
        self.age = age                  = атрибуты

percon = Human(name= "alica", age = "14")                       = Обьект


    Концепция ооп
    наследование - абстракция наследования того что есть в реальном мире.
    инкапсуляция - способ скрыть определенные свойства каждого класса
    полиморфизм - гибкость
    абстракция - сокрытие от конечного пользователя деталей реализации

    Наследование(анг. Inheritance) - концепция ооп согласно которой абстрактный тип данных может наследовать данные и функциональность
    некоторого существенного типа, способствуя повторному использованию компонентов программного обеспечения

    Виды наследований - Единое и множественное (когда один родитель и много)


аналогия с обезьяной которой ходила на 4 ногах и переросла в человека который ходит на двух ногах

Единое
class Human:
    def __init__(self, age):
        self.age = age

    def say_hello(self):
        print("hello, i am {}".format(self.age))

human = Human(age=12)
human.say_hello()

class HumanExtended(Human):    = наследование от класса Human который получает все методы и классы
    def __init__(self, age ,name):
        super().__init__(age)               = подключение атрибутов с прошлого класса
        self.name = name

    def say_hello(self):
        print("Hi, im {} and I am {}".format(self.name, self.age))

human2 = HumanExtended(age=54)
human2.say_hello()


Множественное

аналогия отличий машины игрушечной от настоящей

class A:
    def __init__(self):
        self.a = 10

class B:
    def __init__(self):
        self.b = 5

class C(A,B):
    def __init__(self):
        A.__init__(self)        = вместо super
        B.__init__(self)

c = C()
print(c.a)
print(c.b)


    Статические методы + декораторы

    когда метод в классе не использует обязательные атрибуты класса
    @staticmethod
    def ride_forward(self):
        print("drive forward")

class Car:
    def __init__(self, marka, color, motor):
        self.marka = marka
        self.color = color
        self.motor = motor

    @staticmethod
    def ride_forward():
        print("drive forward")

    @staticmethod
    def ride_back():
        print("drive back")

# car = Car(marka="corolla", color="red", motor=1.5)
# car.ride_forward()
# car.ride_back()

Car.ride_forward()
Car.ride_back()

/////////////////////////////////////////

class FluingCar(CarLeftAndRight, Plane):
    def __init__(self, marka, color, motor, model ):
        CarLeftAndRight.__init__(self, marka, color, motor)
        Plane.__init__(self, model)


fc = FluingCar(marka="LENA", color="red", motor=1.3, model="gg")

////////////////////////////////////////////

class Car:
    def __init__(self, marka, color, motor):
        self.marka = marka
        self.color = color
        self.motor = motor

    @staticmethod
    def ride_forward():
        print("drive forward")

    @staticmethod
    def ride_back():
        print("drive back")


class CarLeftAndRight(Car):
    @staticmethod
    def ride_left():
        print("drive left")

    @staticmethod
    def ride_right():
        print("drive right")


corola = CarLeftAndRight(marka="corolla", color="red", motor=1.5)

corola.ride_forward()
corola.ride_back()
corola.ride_left()
corola.ride_back()

print("")

class Plane():
    def __init__(self, model):
        self.model = model

    @staticmethod
    def flying():
        print("plane frying")

    @staticmethod
    def land():
        print("landing")

Plane.flying()

print("")

class FluingCar(CarLeftAndRight, Plane):
    def __init__(self, marka, color, motor, model ):
        CarLeftAndRight.__init__(self, marka, color, motor)
        Plane.__init__(self, model)


fc = FluingCar(marka="LENA", color="red", motor=1.3, model="gg")
fc.flying()
fc.ride_left()
fc.ride_back()
fc.ride_forward()
fc.land()


///////////////////////////////////////////////////////
https://pythonworld.ru/osnovy/inkapsulyaciya-nasledovanie-polimorfizm.html

Наследование подразумевает то, что дочерний класс содержит все атрибуты родительского класса,
при этом некоторые из них могут быть переопределены или добавлены в дочернем.
Например, мы можем создать свой класс, похожий на словарь:
>>> class Mydict(dict):
...     def get(self, key, default = 0):
...         return dict.get(self, key, default)
...
>>> a = dict(a=1, b=2)
>>> b = Mydict(a=1, b=2)
Класс Mydict ведёт себя точно так же, как и словарь, за исключением того, что метод get по умолчанию возвращает не None, а 0.

>>>
>>> b['c'] = 4
>>> print(b)
{'a': 1, 'c': 4, 'b': 2}
>>> print(a.get('v'))
None
>>> print(b.get('v'))
0

///////////////////////////////////////////////////////


    13.07.22
    Инкапсуляция
Инкапсуляция - еще одно из основных понятий, на котором строится ООП. Она нужна
для того, чтобы организовать уровни доступа к различным архитектурным компонентам,
которые пишет разработчик.
● Есть 3 возможных уровня доступа: private (приватный), protected (защищенный) и public
(публичный).
● Инкапсуляция в Python отличается от ее реализаций в других языках программирования
и носит здесь более неявный характер. Если в других языках используются ключевые
слова вроде public, protected и private, то в Python достаточно добавить символ “_” (один
символ нижнего подчеркивания) перед именем переменной или функции, чтобы
сделать ее protected, а “__” (два символа нижнего подчеркивания) чтобы сделать private.
Public являются все остальные имена, без символов “_” перед ними.
● Например self.__name = ”Alex” является приватным атрибутом и может быть использован
только внутри класса, self._name = “Alex” является защищенным атрибутом и может быть
использован только внутри модуля, а self.name = ”Alex” является публичным и может
быть увиден откуда угодно в коде.
● У данного подхода есть свои преимущества и недостатки. Преимуществом безусловно
является простота реализации. Вам не нужно использовать ключевые слова, а
достаточно добавить “__” или “_” перед именем переменной или функции или не
добавлять вообще. Недостатком же является несовершенство данного подхода.
Приватные переменные по факту не являются таковыми. Если в других языках
программирования вы никак не сможете до них “достучаться” из вне класса, то в Python,
если у вас есть класс A, у него есть атрибут self.__x= 10, то после того как вы создадите
объект класса a = A(), то если вы сделаете print(a.x) будет ошибка, но если вы сделаете
print(a._A__x), то выведется значение переменной __х = 10.
● То есть вам нужно добавить к имени переменной (__х) в начало имя класса с 1 “_” перед
ним. То есть “_ClassName__variable”. Но это очень плохая практика и не нужно ее
использовать в коде. Если делаете приватные переменные, работайте с ними как с
приватными.
Законным способом работать с приватными и защищенными переменными является
использование таких функций как getters и setters. Это специальные функции самого
класса, которые вы сами прописываете и решаете, как именно они должны возвращать
значения приватных/защищенных переменных (getters, например по паролю или просто
так) и как устанавливать значения таких атрибутов (setters)


    Инкапсуляция - принцип при котором пользователь использует только публичную или интерфейсную часть класса и не
    вникает в его внутреннюю реализацию

    Таким образом программист скрывает определенные данные, методы, атрибуты от последующих пользователей




    Уровни доступа у инкапсуляции
    модифкаторы доступа
    _attribute = protected attribute  = работает только в одном модуле
    __attribute = private attribute =  только внутри класса можно обратиться к переменной

class Test:
    def __init__(self, test_value):
        self._public_val = test_value

test = Test(test_value=10)
print(test._public_val)

::
10

class Test:
    def __init__(self, test_value):
        self.__private_val = test_value

    def get_private_val(self):
        return self.__private_val

test = Test(test_value=10)
print(test.get_private_val())
::
10

       Приватная функция
@staticmethod
def __private_function():
    print("Private function")


    getters = дает
    setters = назначает
    Делать через декораторы


    @property
    getters

class User:
    def __init__(self, name):
        self.__name2 = name

    @property
    def name2(self):
        return self.__name2

user = User(name="LENA")
print(user.name2)
::
LENA


    setters


class User:
    def __init__(self, name):
        self.__name2 = name

    @property
    def name2(self):
        return self.__name2

    @name2.setter
    def name2(self,value):
        self.__name2 = value

user = User(name="LENA")
user.name2 = "bob"
print(user.name2)
bob




    @property аналог getter

class User2:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        print("      property")
        return self.__name

k = User2(name="ff")

print(k.name)
::
      property
ff

    setters


    class Worker:
    RIGHT = "Equal"
    SALARY_MAP = {
        "A": 100,
        "B": 200,
        "C": 500
    }
    def __init__(self, working_class):
        self.__salary = self.__get_salary(working_class)

    @staticmethod
    def __get_salary(self, working_class):
        return Worker.SALARY_MAP(working_class, 0)

    @property
    def salary(self):
        return self.salary




# Написать класс, который описывает пользователя (class User), сделать ему приватный
# атрибут age, который передается в конструктор, публичный атрибут name, который так же
# передается в конструктор.
# 2. Написать getter и setter для атрибута age.
# 3. Добавить в setter проверку на валидный возраст (не отрицательное, целое число)

class User:
    def __init__(self, age, name ):
        self.__age = age
        self.name = name

    @property
    def getter_age(self):
        return self.__age

    @getter_age.setter
    def setter_age(self, bob):
        if self.__age <=0 :
            print("get back")
        else:
            return self.__age
            print(" g ")


print("")
print("")
k = User(age=112,name="LENA")
k.getter_age

k.setter_age = "LEHA is not LENA"
print(k.getter_age)
print(k.setter_age)



































































































11.04.21


Списки (list) - упорядоченные коллекции обьектов различных типову каждого списка есть свой индекс, который отвечает его
порядковому номеру в списке, индексация начинается с 0 :: list, или [1,2,3]


Словари dict ({'key':'value'}) - это упорядоченные коллекции формата ключ - значение. Значением может быть любой обьект,
ключом которого может быть только неименяемый обьект.
упорядоченные - указывает что у каждого обьекта есть свой порядковый номер (ключ)
: почти как индекс в списке ::{'key':'value'}


Множества (set) - структура данных, не содержащая повторяющихся элементов. Множества не поддерживают индексацию,
поэтому достук к элементам возможен перебором:: {1,2,3,4}  или set() - пустое множество


Кортеж(tuple) - неизменяемый список :: (1,2,3)






